r [r>1]= 1
r [r<1]= 0
r [r>1]= 1
g1 = graph_from_adjacency_matrix(r , mode = "undirected")
plot(g1)
r [r> 1]= 1
r (r> 1)= 1
r [r> 1]= 1
r [r< 1]= 0
library (igraph)
g1 = graph_from_adjacency_matrix(r , mode = "undirected")
plot(g1)
# co-ocurrencia entre productos t es transpuesta
c
c= co.occurrence(t(M))
c = co.occurrence(t(M))
View(C)
View(c)
View(C)
View(C)
View(C)
View(C)
View(C)
library (EconGeo)
M = as.matrix(
read.csv("https://raw.githubusercontent.com/PABalland/ON/master/amz.csv" ,
sep = ",",
header = T,
row.names = 1))
M
co.occurrence (M)
c = co.occurrence(t(M))
# co-ocurrencia entre productos t es transpuesta
c
r = relatedness (c)
r
r [r< 1]= 0
r [r> 1]= 1
r [r< 1]= 0
r [r> 1]= 1
View(r)
g1 = graph_from_adjacency_matrix(r , mode = "undirected")
plot(g1)
plot(r)
library (igraph)
g1 = graph_from_adjacency_matrix (r , mode = "undirected")
plot(r)
plot(r)
plot(g1)
g1 = graph_from_adjacency_matrix (r , mode = "undirected")
plot(g1)
plot(g1)
View(g1)
plot(g1)
r[r< 1]= 0
r[r> 1]= 1
library (igraph)
g1 = graph_from_adjacency_matrix (r , mode = "undirected")
plot(g1)
plot(g1)
plot(g1)
library (igraph)
g1 =graph_from_adjacency_matrix (r , mode = "undirected")
plot(g1)
library (EconGeo)
plot(g1)
g1 =graph_from_adjacency_matrix (r , mode = "undirected")
library (EconGeo)
M = as.matrix(
read.csv("https://raw.githubusercontent.com/PABalland/ON/master/amz.csv" ,
sep = ",",
header = T,
row.names = 1))
M
co.occurrence (M)
c = co.occurrence(t(M))
# co-ocurrencia entre productos t es transpuesta
c
r = relatedness (c)
r
r[r<1]= 0
r[r>1]= 1
library (igraph)
g1 =graph_from_adjacency_matrix (r , mode = "undirected")
plot(g1)
plot(g1)
g1 = graph_from_adjacency_matrix (r, mode = "undirected")
plot(g1)
#INSTALACIONES
install.packages ("igraph")
install.packages(“visNetwork”)
install.packages("visNetwork")
install.packages("htmlwidgets"")
install.packages("igraph")
install.packages("htmlwidgets")
install.packages("igraph")
install.packages("reforma")
install.packages("Matrix")
install.packages("Siena")
install. paquetes("networkD3")
install.packages("networkD3")
install.packages("curl")
install.packages("devtools"")
biblioteca(devtools)
devtools::install_github("PABalland/EconGeo", force = T)
biblioteca(devtools)
install.packages("devtools")
biblioteca(devtools)
devtools:install_github("PABalland/EconGeo", force = T)
plot(g1)
g1 = graph_from_adjacency_matrix (r, mode = "undirected")
library (EconGeo)
M = as.matrix(
read.csv("https://raw.githubusercontent.com/PABalland/ON/master/amz.csv" ,
sep = ",",
header = T,
row.names = 1))
M
co.occurrence (M)
c = co.occurrence(t(M))
# co-ocurrencia entre productos t es transpuesta
c
r = relatedness (c)
r
r[r<1]= 0
r[r>1]= 1
library (igraph)
library (igraph)
g1 = graph_from_adjacency_matrix (r, mode = "undirected")
plot(g1)
library(readr)
rca_2014 <- read_csv("C:/Users/gusta/Downloads/rca_2014.csv")
View(rca_2014)
library(readr)
rca_2014 <- read_csv("C:/Users/gusta/Downloads/rca_2014.csv")
View(rca_2014)
library (EconGeo)
M = as.matrix("C:/Users/gusta/Downloads/rca_2014.csv"
read.csv("RUTA" ,
View(rca_2014)
M = as.matrix(
read.csv("C:/Users/gusta/Downloads/rca_2014.csv",
sep = ",",
header = T,
row.names = 1))
M = as.matrix(
read.csv("C:/Users/gusta/Downloads/rca_2014.csv",
sep = ",",
header = T,
row.names = 1))
head (M[,1:10])
dim (M)
co.ocurrence (M)
co.occurrence(M)
c= co.occurrence(t(M))
# co-ocurrencia entre productos t es transpuesta
c
r = relatedness(c)
# estima el relacionamiento o proximidad pero normalizado, para asegurar que el numero de co ocurrencias que observamos
# es mayor al numero de co ocurrencias probables (probailidad condicional)
#tie and Surfboard puede que no esten tan relacionados, abajo de  1 no es relacionado mientras que mayor a 1 si es relacionado
r
r[r<1] = 0
r[r>1] = 1
r
library (igraph)
g1 = graph_from_adjacency_matrix(r, mode = "undirected")
plot(g1)
#exportar resultados del relacionamiento binario
write.csv(r,file = "relatedness.csv")
write.csv(c,file = "cocurrences.csv")
M= matrix(runif(200*200, min=0, max=100, ncol=200)
diag(M) < - 0
M <- matrix(runif(200*200, min=0, max=100, ncol=200))
M <- matrix(runif(200*200, min=0, max=100, ncol=200)
diag(M) <- 0
M <- matrix(runif(200*200, min=0, max=100, ncol(200))
diag(M) <- 0
M <- matrix(runif(200*200, min=0, max=100), ncol=200)
diag(M) <- 0
head(M[,1:6])
dim(M)
library (igraph)
g <-graph.adjacency(M, mode="undirected", weighted = TRUE)
plot g
View(g)
plot g
plot (g)
M<- -M
head(M[,1:6])
g<-  graph.adjacency(M, mode = "undirected", weighted = TRUE)
MST <- minimum.spanning.tree(g)
plot(MST, vertex.shape="none", vertex.label.cex=.7)
g<-  graph.adjacency(M, mode = "undirected", weighted = TRUE)
MST <- minimum.spanning.tree(g)
g <-graph.adjacency(M, mode ="undirected", weighted = TRUE)
MST <- minimum.spanning.tree(g)
plot(MST, vertex.shape="none", vertex.label.cex=.7)
M <- -M
head(M[,1:6])
g <-graph.adjacency(M, mode ="undirected", weighted = TRUE)
MST <- minimum.spanning.tree(g)
plot(MST, vertex.shape="none", vertex.label.cex=.7)
g <-graph.adjacency(M, mode ="undirected", weighted = TRUE)
MST<- minimum.spanning.tree(g)
plot(MST, vertex.shape="none", vertex.label.cex=.7)
M <- -M
head(M[,1:6])
#Transforma la matriz en en NEGATIVA y para identificar los máximos
M
g <-graph.adjacency(M, mode ="undirected", weighted = TRUE)
MST<- minimum.spanning.tree(g)
g <-graph.adjacency(M, mode="undirected", weighted = TRUE)
plot (g)
M <- -M
M <- matrix(runif(200*200, min=0, max=100), ncol=200)
diag(M) <- 0
head(M[,1:6])
dim(M)
library (igraph)
g <-graph.adjacency(M, mode="undirected", weighted = TRUE)
plot (g)
library (igraph)
g <-graph.adjacency(M, mode="undirected", weighted = TRUE)
plot (g)
M <- -M
head(M[,1:6])
g <-graph.adjacency(M, mode ="undirected", weighted = TRUE)
MST<- minimum.spanning.tree(g)
plot(MST, vertex.shape="none", verteX.label.cex=.7)
A<- get.adjacency(MST, sparse = F)
# matriz de adyacencias (nuevo relacionamiento)
# ver las aristas que hay entre los nodos
head(A)
write.graph(MST.file="g.gml", format = "gml")
write.graph(MST.file="g.gml", format = "gml")
write.graph(MST.file="g.gml", format = "gml")
g <-graph.adjacency(M, mode="undirected", weighted = TRUE)
MST<- minimum.spanning.tree(g)
plot(MST, vertex.shape="none", vertex.label.cex=.7)
A<- get.adjacency(MST, sparse = F)
# matriz de adyacencias (nuevo relacionamiento)
# ver las aristas que hay entre los nodos
head(A)
write.graph(MST.file="g.gml", format = "gml")
write_graph(MST.file="g.gml", format = "gml")
write.graph(MST.file="g.gml", format = "gml")
write.graph(MST,file="g.gml", format = "gml")
write.csv(A, file "Adyacentes.csv")
write.csv(A, file= "Adyacentes.csv")
file.choose()
M = as.matrix(
read.csv(C:\\Users\\gusta\\OneDrive\\Documents\\GitHub\\JPAS_LAB11\\INPUT\\relatednessbinario.csv" ,
row.names = 1))
M = as.matrix(
read.csv("C:\Users\gusta\OneDrive\Documents\GitHub\JPAS_LAB11\INPUT\relatednessbinario.csv" ,
M = as.matrix(
read.csv("C:\\Users\\gusta\\OneDrive\\Documents\\GitHub\\JPAS_LAB11\\INPUT\\relatednessbinario.csv" ,
sep = ",",
header = T,
row.names = 1))
head (M[,1:10])
dim (M)
library (igraph)
red_hidalgo <- graph.adjacency(M, mode = "undireted")
library (igraph)
red_hidalgo1 <- graph.adjacency(M, mode = "undireted")
library (igraph)
red_hidalgo1 <- graph.adjacency(M, mode = "undireted")
library (igraph)
red_hidalgo1 <- graph.adjacency(M, mode = "undireted" k weighted= TRUE)
library (igraph)
red_hidalgo1 <- graph.adjacency(M, mode= "undireCted" , weighted= TRUE)
plot(red_hidalgo1)
M <- -M
head(M[0:6])
M <- -M
head(M[0:6])
M <- -M
head(M[,1:6])
red_hidalgo2 < graph.adjacency(M, mode = "undirected", weighted = TRUE)
red_hidalgo2 < graph.adjacency(M, mode = "undirected", weighted = TRUE)
red_hidalgo2 <- graph.adjacency(M, mode= "undirected", weighted = TRUE)
MST <- minimum.spanning.tree(red_hidalgo2)
plot(MST, vertex.shape= "none", vertex.label.cex=.7)
View(red_hidalgo1)
View(red_hidalgo2)
View(red_hidalgo2)
write.graph(MST.file= "redhidalgo2.gml", format="gml")
write.graph(MST,file= "redhidalgo2.gml", format="gml")
A <- get.adjacency(MST. sparse = F)
A <- get.adjacency(MST, sparse = F)
write.csv(A, file = "AdyacentesConMST.csv")
library (EconGeo)
?RCA
set.seed(31)
mat <- matrix(sample(0:100,20, replace = T), ncol=4)
rownames (mat) <- c ("R1", "R2", "R3", "R4", "R5")
colnames(mat) <- c ("I1", "I2", "I3", "I4")
mat
dim(mat)
mat= RCA(mat, binary = 1)
mat
c = co.occurrence(t(mat))
c
r= relatedness(c)
r
r[r<1] =0
r[r>1] =1
r
mat
rd= relatedness.density(mat,r)
rd
rd=get.list(rd)
rd = get.list(rd)
rd
# 6. Predecir entrada
?entry.list #Mira la sección de ejemplos. Copia-pega los datos a la consola
colnames(mat1) <- c ("I1", "I2", "I3", "I4")
set.seed(31)
mat1 <- matrix(sample(0:1,20,replace=T), ncol = 4)
rownames(mat1) <- c ("R1", "R2", "R3", "R4", "R5")
colnames(mat1) <- c ("I1", "I2", "I3", "I4")
mat1
mat2 <- mat1
mat2[3,1] <- 1
mat2
mat1
d = entry.list(mat1,mat2)
d
colnames(d) = c("Region", "Industry", "Entry", "Period")
d= merge(d, rd, by= c("Region", "Industry"))
d
summary(lm(d$Entry ~ d$Count))
mat2
mat1
mat2
mat1
d = entry.list(mat1,mat2)
d
colnames(d) = c("Region", "Industry", "Entry", "Period")
d= merge(d, rd, by= c("Region", "Industry"))
d
summary (lm(d$Entry ~ d$Count))
install.packages("ggplot2")
# cargar libreria ggplot2
library(ggplot2)
library(readr)
correl <- read_csv("GitHub/JPAS_LAB13/correl.csv")
View(correl)
library(readr)
REGESIONES_FINALES <- read_csv("GitHub/JPAS_LAB13/REGESIONES FINALES.csv")
View(REGESIONES_FINALES)
# leer df
green_data <- read.csv("REGESIONES FINALES.csv")
("GitHub/JPAS_LAB13/REGESIONES FINALES.csv")
green_data <- read.csv("GitHub/JPAS_LAB13/REGESIONES FINALES.csv")
# echando un ojo a los datos
names(green_data)
p1 <- ggplot(data = green_data,
mapping = aes(x = ICE_index,
y = GCI_index,)) +
geom_point()+
geom_text(label= green_data$STATE,
color= "black",
size= 4)+
geom_point() +
geom_smooth(method = lm,
se=FALSE,
fullrange =T)
p1
<- ggplot(data = green_data,
p2 <- ggplot(data = green_data,
mapping = aes(x = ICE_rank,
y = GCI_rank,)) +
geom_point()+
geom_text(label= green_data$STATE,
color= "black",
size= 4)+
geom_point() +
geom_smooth(method = lm,
se=FALSE,
fullrange =T)
p2
<- ggplot(data = green_data,
p3 <- ggplot(data = green_data,
mapping = aes(x = LPIBE,
y = GCI_index,)) +
geom_point()+
geom_text(label= green_data$STATE,
color= "black",
size= 4)+
geom_point() +
geom_smooth(method = lm,
se=FALSE,
fullrange =T)
p3
### correl1
install.packages("psych")
library(psych)
library(readr)
correl <- read_csv("correl.csv")
correl <- read_csv("GitHub/JPAS_LAB13/correl.csv")
View(correl)
View(correl)
attach(correl)
names(correl)
pairs(correl)
pairs.panels(correl)
# Calculamos la correlación
complex_corr <- cor(correl, method = "pearson")
complex_corr
# Redondeamos
complex_corr =round(complex_corr, digits=2)
complex_corr
#matriz de correlación
install.packages("ggcorrplot")
library(ggcorrplot)
library(ggplot2)
p4 <- ggcorrplot(complex_corr, method = "circle", type= "lower", lab= TRUE)
ggtitle("Matriz de correlación")
theme_ minimal ()
p4
#####
install.packages("ggpubr")
ggpubr :: ggarrange (p1, p2, p3, p4, etiquetas = c ("A", "B", "C" , "D"))
library(ggplot2)
install.packages("gridExtra")
require (gridExtra)
F1 <- grid.arrange (p1, p2, p3, p4, nrow = 2)
F1 <- grid.arrange (p1, p2, p3, p4, nrow = 2)
# LABORATORIO - Analisis de Redes en R - Indicadores básicos Globales
library(EconGeo)
# cargar DATA
EL= read.csv("https://raw.githubsercontent.com/PABalland/ON/master/lesmis-el.csv")
# ver encabezado
head(EL)
# cargar DATA
EL= read.csv("https://raw.githubusercontent.com/PABalland/ON/master/lesmis-el.csv")
# ver encabezado
head (EL)
#transformar a  matriz
MM <- get.matrix(EL)
#Graficar
library(igraph)
g <- graph_from_data_frame(d=EL, directed = FALSE)
#transformar a  matriz
MM <- get.matrix(EL)
library(igraph)
g <- graph_from_data_frame(d=EL, directed = FALSE)
g
View(MM)
plot(g)
EL$Weight = NULL
head(EL)
#grafico tridimensional
install.packages("networkD3")
library(networkD3)
simpleNetwork(EL)
simpleNetwork(EL)
#instalando paquete
install.packages("ggplot2")
library(readr)
PARA_FACETING <- read_csv("C:/Users/gusta/Downloads/PARA FACETING.csv")
View(PARA_FACETING)
#buscar df
file.choose("C:/Users/gusta/Downloads/PARA FACETING.csv")
# leer base
densidad_verde <- read.csv("C:/Users/gusta/Downloads/PARA FACETING.csv")
# leer base
densidad_verde <- read.csv("C:/Users/gusta/Downloads/PARA FACETING.csv")
#ver nombres
names(densidad_verde)
p <- ggplot(data= densidad_verde,
mapping = aes(x= DENSITY,
y= PCI.2018,
color= Region))+
geom_point()
# cargar libreria ggplot2
library(ggplot2)
#instalando paquete
install.packages("ggplot2")
install.packages("ggplot2")
# cargar libreria ggplot2
library(ggplot2)
#buscar df
file.choose("C:/Users/gusta/Downloads/PARA FACETING.csv")
# leer base
densidad_verde <- read.csv("C:/Users/gusta/Downloads/PARA FACETING.csv")
#ver nombres
names(densidad_verde)
p <- ggplot(data= densidad_verde,
mapping = aes(x= DENSITY,
y= PCI.2018,
color= Region))+
geom_point()
# crear objeto p
p
# facet_wrap (recomendado con una variable)
p + facet_wrap(~ Region)
# manipulando número de filas
p + facet_wrap( ~ Region, nrow = 3)
# manipulando número de columnas
p + facet_wrap(~ Region, ncol = 5)
p
# facet_wrap (recomendado con una variable)
p + facet_wrap(~ Region)
# manipulando número de filas
p + facet_wrap( ~ Region, nrow = 5)
# manipulando número de columnas
p + facet_wrap(~ Region, ncol = 3)
savehistory("C:/Users/gusta/OneDrive/Documents/GitHub/JPAS_LABS20/OUTPUT/LAB20_History.Rhistory")
